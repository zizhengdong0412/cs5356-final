{"version":3,"sources":["../src/adapters/node/index.ts","../src/adapters/node/request.ts"],"sourcesContent":["import type { IncomingMessage, ServerResponse } from \"node:http\";\n\nimport { getRequest, setResponse } from \"./request\";\nimport type { Router } from \"../../router.js\";\n\nexport function toNodeHandler(handler: Router[\"handler\"]) {\n\treturn async (req: IncomingMessage, res: ServerResponse) => {\n\t\tconst protocol =\n\t\t\treq.headers[\"x-forwarded-proto\"] || ((req.socket as any).encrypted ? \"https\" : \"http\");\n\t\tconst base = `${protocol}://${req.headers[\":authority\"] || req.headers.host}`;\n\t\tconst response = await handler(getRequest({ base, request: req }));\n\t\treturn setResponse(res, response);\n\t};\n}\n\nexport { getRequest, setResponse };\n","import type { IncomingMessage, ServerResponse } from \"node:http\";\nimport * as set_cookie_parser from \"set-cookie-parser\";\n\nfunction get_raw_body(req: IncomingMessage, body_size_limit?: number) {\n\tconst h = req.headers;\n\n\tif (!h[\"content-type\"]) return null;\n\n\tconst content_length = Number(h[\"content-length\"]);\n\n\t// check if no request body\n\tif (\n\t\t(req.httpVersionMajor === 1 && isNaN(content_length) && h[\"transfer-encoding\"] == null) ||\n\t\tcontent_length === 0\n\t) {\n\t\treturn null;\n\t}\n\n\tlet length = content_length;\n\n\tif (body_size_limit) {\n\t\tif (!length) {\n\t\t\tlength = body_size_limit;\n\t\t} else if (length > body_size_limit) {\n\t\t\tthrow Error(\n\t\t\t\t`Received content-length of ${length}, but only accept up to ${body_size_limit} bytes.`,\n\t\t\t);\n\t\t}\n\t}\n\n\tif (req.destroyed) {\n\t\tconst readable = new ReadableStream();\n\t\treadable.cancel();\n\t\treturn readable;\n\t}\n\n\tlet size = 0;\n\tlet cancelled = false;\n\n\treturn new ReadableStream({\n\t\tstart(controller) {\n\t\t\treq.on(\"error\", (error) => {\n\t\t\t\tcancelled = true;\n\t\t\t\tcontroller.error(error);\n\t\t\t});\n\n\t\t\treq.on(\"end\", () => {\n\t\t\t\tif (cancelled) return;\n\t\t\t\tcontroller.close();\n\t\t\t});\n\n\t\t\treq.on(\"data\", (chunk) => {\n\t\t\t\tif (cancelled) return;\n\n\t\t\t\tsize += chunk.length;\n\n\t\t\t\tif (size > length) {\n\t\t\t\t\tcancelled = true;\n\n\t\t\t\t\tcontroller.error(\n\t\t\t\t\t\tnew Error(\n\t\t\t\t\t\t\t`request body size exceeded ${\n\t\t\t\t\t\t\t\tcontent_length ? \"'content-length'\" : \"BODY_SIZE_LIMIT\"\n\t\t\t\t\t\t\t} of ${length}`,\n\t\t\t\t\t\t),\n\t\t\t\t\t);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tcontroller.enqueue(chunk);\n\n\t\t\t\tif (controller.desiredSize === null || controller.desiredSize <= 0) {\n\t\t\t\t\treq.pause();\n\t\t\t\t}\n\t\t\t});\n\t\t},\n\n\t\tpull() {\n\t\t\treq.resume();\n\t\t},\n\n\t\tcancel(reason) {\n\t\t\tcancelled = true;\n\t\t\treq.destroy(reason);\n\t\t},\n\t});\n}\n\nexport function getRequest({\n\trequest,\n\tbase,\n\tbodySizeLimit,\n}: {\n\tbase: string;\n\tbodySizeLimit?: number;\n\trequest: IncomingMessage;\n}) {\n\treturn new Request(base + request.url, {\n\t\t// @ts-expect-error\n\t\tduplex: \"half\",\n\t\tmethod: request.method,\n\t\tbody: get_raw_body(request, bodySizeLimit),\n\t\theaders: request.headers as Record<string, string>,\n\t});\n}\n\nexport async function setResponse(res: ServerResponse, response: Response) {\n\tfor (const [key, value] of response.headers as any) {\n\t\ttry {\n\t\t\tres.setHeader(\n\t\t\t\tkey,\n\t\t\t\tkey === \"set-cookie\"\n\t\t\t\t\t? set_cookie_parser.splitCookiesString(response.headers.get(key) as string)\n\t\t\t\t\t: value,\n\t\t\t);\n\t\t} catch (error) {\n\t\t\tres.getHeaderNames().forEach((name) => res.removeHeader(name));\n\t\t\tres.writeHead(500).end(String(error));\n\t\t\treturn;\n\t\t}\n\t}\n\n\tres.writeHead(response.status);\n\n\tif (!response.body) {\n\t\tres.end();\n\t\treturn;\n\t}\n\n\tif (response.body.locked) {\n\t\tres.end(\n\t\t\t\"Fatal error: Response body is locked. \" +\n\t\t\t\t\"This can happen when the response was already read (for example through 'response.json()' or 'response.text()').\",\n\t\t);\n\t\treturn;\n\t}\n\n\tconst reader = response.body.getReader();\n\n\tif (res.destroyed) {\n\t\treader.cancel();\n\t\treturn;\n\t}\n\n\tconst cancel = (error?: Error) => {\n\t\tres.off(\"close\", cancel);\n\t\tres.off(\"error\", cancel);\n\n\t\t// If the reader has already been interrupted with an error earlier,\n\t\t// then it will appear here, it is useless, but it needs to be catch.\n\t\treader.cancel(error).catch(() => {});\n\t\tif (error) res.destroy(error);\n\t};\n\n\tres.on(\"close\", cancel);\n\tres.on(\"error\", cancel);\n\n\tnext();\n\tasync function next() {\n\t\ttry {\n\t\t\tfor (;;) {\n\t\t\t\tconst { done, value } = await reader.read();\n\n\t\t\t\tif (done) break;\n\n\t\t\t\tif (!res.write(value)) {\n\t\t\t\t\tres.once(\"drain\", next);\n\t\t\t\t\treturn;\n\t\t\t\t}\n\t\t\t}\n\t\t\tres.end();\n\t\t} catch (error) {\n\t\t\tcancel(error instanceof Error ? error : new Error(String(error)));\n\t\t}\n\t}\n}\n"],"mappings":"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","names":[]}